// File: ComponentConfig.ts

export interface TextareaProperties {
    label: string;
    placeholder?: string;
    fieldName: string; // binds the field to the data. must include the path to the data. example: user.name.firstName
    action: ActionNames; // String identifier for the action
}
export interface ButtonProperties {
    text: string;
    action: ActionNames;
}
export interface HeadlineProperties {
    text: string;
    level: 1 | 2 | 3 | 4 | 5 | 6;
}
export interface InputProperties { // used for editable data
    label: string;
    placeholder?: string;
    fieldName: string;
    action: ActionNames;
}
export interface ImageProperties {
    fieldName: string; // path to src in the data
    alt: string;
}
export interface LinkProperties {
    fieldName: string; // path to the src in the data
}
export interface TextProperties { // used for plain text
    fieldName: string;
    fontSize: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
}
export interface LabeledTextProperties {
    fieldName: string;
    label: string // the label of the value
    separator: ':' // label : text
    fontSize: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
}
export interface ListProperties { // always used for arrays
    fieldName: string; // name of the field where the array can be found
    layout: LayoutConfig; // the layout of a list entry
}
export interface FlexLayoutProperties extends LayoutConfig { // can be nested
    direction: 'row' | 'column';
    components: ComponentConfig[];
}
export interface CardLayoutProperties extends LayoutConfig { // can be nested
    components: ComponentConfig[]; // the body of the card
}
export interface ComponentConfig { // describes the above components
    type: 'Input' | 'Button' | 'Headline' | 'Textarea' | 'FlexLayout' | 'CardLayout' | 'Image' | 'Text' | 'LabeledText' | 'List' | 'Link';
    properties: InputProperties | ButtonProperties | HeadlineProperties | TextareaProperties | FlexLayoutProperties | ImageProperties | CardLayoutProperties | TextProperties | LabeledTextProperties | ListProperties | LinkProperties;
}
export interface LayoutConfig { // the root of the components
    components: ComponentConfig[];
}


// File: Section.tsx

export interface SectionT {
  layout: LayoutConfig;
  data: any;
}
const Section: FC<SectionT> = ({ layout, data }) => {
  return useMemo(() => {
    if (layout) {
      return (
        <SectionDataProvider initialData={data}>
          <PathProvider>
            <ParsedLayout config={layout}/>
          </PathProvider>
        </SectionDataProvider>
      );
    }
    return <Text>Please generate or select a layout</Text>;
  }, [layout]);
};
export default Section;


// File: ParsedComponent.tsx

import type {
  ButtonProperties, CardLayoutProperties,
  ComponentConfig, FlexLayoutProperties,
  HeadlineProperties, ImageProperties,
  InputProperties, LabeledTextProperties, LinkProperties, ListProperties,
  TextareaProperties, TextProperties
} from '@/dynamicUI/components/ComponentConfig';
const ParsedComponent: FC<{ config:  ComponentConfig}> = ({ config }) => {
  const { type, properties } = config;
  switch (type) {
    case 'Headline':
      return <HeadlineComponent properties={properties as HeadlineProperties} />;
    case 'Input':
      return (
        <InputComponent properties={properties as InputProperties} />
      );
    case 'Textarea':
      return (
        <TextareaComponent properties={properties as TextareaProperties} />
      );
    case 'Button':
      return <ButtonComponent properties={properties as ButtonProperties} />;
    case 'FlexLayout':
      return (
        <FlexLayoutComponent properties={properties as FlexLayoutProperties}>
          <ParsedLayout config={properties as FlexLayoutProperties} />
        </FlexLayoutComponent>
      );
    case 'Image':
      return <ImageComponent properties={properties as ImageProperties} />;
    case 'CardLayout':
      return (
        <CardLayoutComponent properties={properties as CardLayoutProperties}>
          <ParsedLayout config={properties as CardLayoutProperties} />
        </CardLayoutComponent>
      );
    case 'Text':
      return (
        <TextComponent properties={properties as TextProperties} />
      );
    case 'LabeledText':
      return (
        <LabeledTextComponent properties={properties as LabeledTextProperties} />
      );
    case 'List':
      return (
        <ListComponent properties={properties as ListProperties} />
      );
    case 'Link':
      return (
        <LinkComponent properties={properties as LinkProperties} />
      );
    default:
      return type;
  }
};
export default ParsedComponent;


// File: ParsedLayout.tsx

const ParsedLayout: FC<{ config: LayoutConfig}> = ({ config }) => {
  return useMemo(() => {
    if (Array.isArray(config?.components)) {
      return config.components.map((componentConfig: ComponentConfig) => {
        return <ParsedComponent key={getUUIDv4()} config={componentConfig}/>;
      });
    } else {
      console.log('illegal config', config);
    }
  }, [config]);
};
export default ParsedLayout;


// File: SectionDataProvider.tsx

const SectionDataContext = createContext<SectionDataContextType | undefined>(undefined);
interface SectionContextState {
  [key: string]: unknown;
}
export interface SectionDataProviderProps {
  children: ReactNode,
  initialData: SectionContextState;
}
interface SectionDataContextType {
  setState: (path: string, value: unknown) => void;
  getState: <T,>(path: string) => T | undefined;  // You can specify a return type more specific than `any`
}
export const SectionDataProvider = ({ children, initialData }: SectionDataProviderProps) => {
  const [state, setState] = useState<SectionContextState>(initialData);
  useEffect(() => {
    setState(initialData);
  }, [initialData]);
  const parsePath = (path: string) => {
    // This function splits paths and translates array access into plain keys
    const pathArray = path.match(/[^.[\]]+|\[\d+]/g) ?? [];
    return pathArray.map(segment => segment.replace(/^\[(\d+)]$/, '$1'));  // Convert ['0'] to '0' for array access
  };
  const getStateFromPath = useCallback(<T,>(path: string): T | undefined => {
    const parts = parsePath(path);
    const result = parts.reduce((acc: unknown, part: string) => {
      if (acc && typeof acc === 'object') {
        if (Array.isArray(acc) && /^\d+$/.test(part)) {
          return acc[parseInt(part)];
        } else if (part in acc) {
          return (acc as Record<string, unknown>)[part];
        }
      }
      return undefined;
    }, state as unknown);
    return result as T;
  },[state]);
  const setStateAtPath = useCallback((path: string, value: unknown): void => {
    const keys = path.split('.').map(key => key.replace(/\[(\d+)\]/g, '.$1')); // Handle array indices
    const lastKey = keys.pop();
    const lastObj = keys.reduce((obj, key) => {
      // Ensure each key is valid for an object, initialize if necessary
      if (typeof obj[key] !== 'object' || obj[key] === null) obj[key] = {};
      return obj[key] as Record<string, unknown>;
    }, state);
    // Set the new value
    if (lastKey) {
      (lastObj as Record<string, unknown>)[lastKey] = value;
    }
    // Trigger a state update with a new object for immutability
    setState({ ...state });
  }, [state]);
  const value = useMemo(() => ({
    setState: setStateAtPath,
    getState: getStateFromPath
  }), [state]);
  return (
    <SectionDataContext.Provider value={value}>
      {children}
    </SectionDataContext.Provider>
  );
};
export const useSectionDataContext = (): SectionDataContextType => {
  const context = useContext(SectionDataContext);
  if (!context) {
    throw new Error('SectionDataContext can only be used within SectionDataProvider');
  }
  return context;
};


// File: PathProvider.tsx

export const PathContext = createContext('');
export interface PathProviderProps {
  children: ReactNode,
  path?: string,
}
export const PathProvider = ({ children, path = '' }: PathProviderProps) => {
  const parentPath = useContext(PathContext);
  const fullPath = parentPath && path ? `${parentPath}.${path}` : parentPath || path;
  return (
    <PathContext.Provider value={fullPath}>
      {children}
    </PathContext.Provider>
  );
};
export const usePathContext = () => {
  return useContext(PathContext);
};
export const useFullPath = (fieldName: string): string => {
  const parentPath = useContext(PathContext);
  return parentPath ? `${parentPath}.${fieldName}` : fieldName;
};


// File: ListComponent.tsx

const ListComponent: FC<{ properties: ListProperties}> = ({ properties }) => {
  const { getState } = useSectionDataContext();
  const fullPath = useFullPath(properties.fieldName);
  const list = getState<any[]>(fullPath) ?? [];
  return useMemo(() => (
    <List>
      <Stack spacing={5}>
        { list.map((_, index) => {
          const entryPath = `${fullPath}[${index}]`;
          return (
            <PathProvider path={entryPath} key={entryPath}>
              <ParsedLayout config={properties.layout} />
            </PathProvider>);
        })}
      </Stack>
    </List>
  ), [list]);
};
export default ListComponent;
